import { __decorate, __metadata } from 'tslib';
import { Renderer2, ElementRef, Input, HostListener, Directive, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_ASYNC_VALIDATORS, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { of, forkJoin, fromEventPattern, ReplaySubject } from 'rxjs';
import { take, map, shareReplay, first } from 'rxjs/operators';

var FileInputAccessor_1;
let FileInputAccessor = FileInputAccessor_1 = class FileInputAccessor {
    constructor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this.validator = this.generateAsyncValidator();
    }
    set allowedExt(value) {
        if (typeof value === 'string') {
            value = value + '$';
        }
        if (value instanceof Array) {
            value = value.join('|') + '$';
        }
        this._allowedExt = value;
    }
    get allowedExt() {
        return this._allowedExt;
    }
    writeValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', null);
    }
    registerOnChange(fn) {
        this.onChange = this.onChangeGenerator(fn);
    }
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    validate(c) {
        return this.validator(c);
    }
    /**
     * Generator method that I used to move the code for the AsyncValidator down here so it didn't
     * get in my way, way up there ^.
     */
    generateAsyncValidator() {
        return (c) => {
            if (!c.value || !c.value.length || c.disabled)
                return of({});
            const errors = {};
            const loaders = [];
            for (const f of c.value) {
                if (this.size && this.size < f.size) {
                    f.errors.fileSize = true;
                    errors.fileSize = true;
                }
                if (f.isImg && (this.maxWidth || this.maxHeight || this.minWidth || this.minHeight)) {
                    loaders.push(f.imgLoadReplay
                        .pipe(take(1), map((e) => {
                        const minWidthError = this.minWidth && f.imgWidth < this.minWidth;
                        const minHeightError = this.minHeight && f.imgHeight < this.minHeight;
                        const maxWidthError = this.maxWidth && f.imgWidth > this.maxWidth;
                        const maxHeightError = this.maxHeight && f.imgHeight > this.maxHeight;
                        if (minWidthError) {
                            f.errors.minWidth = true;
                            errors.minWidth = true;
                        }
                        if (minHeightError) {
                            f.errors.minHeight = true;
                            errors.minHeight = true;
                        }
                        if (maxWidthError) {
                            f.errors.maxWidth = true;
                            errors.maxWidth = true;
                        }
                        if (maxHeightError) {
                            f.errors.maxHeight = true;
                            errors.maxHeight = true;
                        }
                        /** will be @deprecated **/
                        if (minWidthError || maxWidthError) {
                            f.errors.imageWidth = true;
                            errors.imageWidth = true;
                        }
                        /** will be @deprecated **/
                        if (minHeightError || maxHeightError) {
                            f.errors.imageHeight = true;
                            errors.imageHeight = true;
                        }
                        return e;
                    })));
                }
                if (!this.allowedExt && !this.allowedTypes)
                    continue;
                const extP = this.generateRegExp(this.allowedExt);
                const typeP = this.generateRegExp(this.allowedTypes);
                if (extP && !extP.test(f.name)) {
                    f.errors.fileExt = true;
                    errors.fileExt = true;
                }
                if (typeP && !typeP.test(f.type)) {
                    f.errors.fileType = true;
                    errors.fileType = true;
                }
            }
            if (loaders.length) {
                return forkJoin(...loaders).pipe(map(() => errors));
            }
            return of(errors);
        };
    }
    /**
     * Generator method that returns an onChange handler
     */
    onChangeGenerator(fn) {
        return (files) => {
            const fileArr = [];
            for (const f of files) {
                if (this.withMeta && FileReader) {
                    const fr = new FileReader();
                    this.generateFileMeta(f, fr);
                }
                f.errors = {};
                fileArr.push(f);
            }
            fn(fileArr);
        };
    }
    generateRegExp(pattern) {
        if (!pattern)
            return null;
        if (pattern instanceof RegExp) {
            return new RegExp(pattern);
        }
        else if (typeof pattern === 'string') {
            return new RegExp(pattern, 'ig');
        }
        else if (pattern instanceof Array) {
            return new RegExp(`(${pattern.join('|')})`, 'ig');
        }
        return null;
    }
    /**
     * The ICustomFile has a ReplaySubject property for text / image files that will emit
     * once the file has been loaded. Might get removed later since I haven't found a use for it yet.
     */
    generateFileMeta(f, fr) {
        if (f.type.match(/text.*/)) {
            f.textLoadReplay = this.setText(f, fr);
        }
        else if (f.type.match(/image.*/)) {
            f.imgLoadReplay = this.setImage(f, fr);
        }
    }
    setImage(f, fr) {
        f.isImg = true;
        const img = new Image();
        const imgLoadObs = fromEventPattern(((handler) => img.addEventListener('load', handler)), ((handler) => img.removeEventListener('load', handler))).pipe(take(1), shareReplay());
        const frLoadObs = fromEventPattern(((handler) => fr.addEventListener('load', handler)), ((handler) => fr.removeEventListener('load', handler))).pipe(take(1), shareReplay());
        const onloadReplay = new ReplaySubject(1);
        forkJoin(imgLoadObs, frLoadObs).pipe(first()).subscribe(onloadReplay);
        imgLoadObs.pipe(first()).subscribe(() => {
            f.imgHeight = img.height;
            f.imgWidth = img.width;
        });
        frLoadObs.pipe(first()).subscribe(() => {
            f.imgSrc = fr.result + '';
            img.src = fr.result + '';
        });
        fr.readAsDataURL(f);
        return onloadReplay;
    }
    setText(f, fr) {
        const frLoadObs = fromEventPattern(((handler) => fr.addEventListener('load', handler)), ((handler) => fr.removeEventListener('load', handler))).pipe(take(1), shareReplay());
        const onloadReplay = new ReplaySubject(1);
        frLoadObs.subscribe(onloadReplay);
        frLoadObs.pipe(first()).subscribe(() => {
            f.textContent = fr.result + '';
        });
        fr.readAsText(f);
        return onloadReplay;
    }
};
FileInputAccessor.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], FileInputAccessor.prototype, "allowedTypes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FileInputAccessor.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FileInputAccessor.prototype, "withMeta", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FileInputAccessor.prototype, "maxHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FileInputAccessor.prototype, "maxWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FileInputAccessor.prototype, "minHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FileInputAccessor.prototype, "minWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FileInputAccessor.prototype, "allowedExt", null);
__decorate([
    HostListener('change', ['$event.target.files']),
    __metadata("design:type", Object)
], FileInputAccessor.prototype, "onChange", void 0);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Object)
], FileInputAccessor.prototype, "onTouched", void 0);
FileInputAccessor = FileInputAccessor_1 = __decorate([
    Directive({
        selector: 'input[type=file][formControl],input[type=file][formControlName],input[type=file][ngModel]',
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => FileInputAccessor_1),
                multi: true
            },
            {
                provide: NG_ASYNC_VALIDATORS,
                useExisting: forwardRef(() => FileInputAccessor_1),
                multi: true
            }
        ]
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], FileInputAccessor);

let FileInputAccessorModule = class FileInputAccessorModule {
};
FileInputAccessorModule = __decorate([
    NgModule({
        declarations: [FileInputAccessor],
        imports: [
            FormsModule,
            ReactiveFormsModule
        ],
        exports: [
            FileInputAccessor,
            FormsModule,
            ReactiveFormsModule
        ]
    })
], FileInputAccessorModule);

/*
 * Public API Surface of file-input-accessor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FileInputAccessor, FileInputAccessorModule };
//# sourceMappingURL=file-input-accessor.js.map
