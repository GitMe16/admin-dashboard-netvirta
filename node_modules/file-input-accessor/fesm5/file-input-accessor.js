import { __values, __spread, __decorate, __metadata } from 'tslib';
import { Renderer2, ElementRef, Input, HostListener, Directive, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_ASYNC_VALIDATORS, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { of, forkJoin, fromEventPattern, ReplaySubject } from 'rxjs';
import { take, map, shareReplay, first } from 'rxjs/operators';

var FileInputAccessor = /** @class */ (function () {
    function FileInputAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
        this.validator = this.generateAsyncValidator();
    }
    FileInputAccessor_1 = FileInputAccessor;
    Object.defineProperty(FileInputAccessor.prototype, "allowedExt", {
        get: function () {
            return this._allowedExt;
        },
        set: function (value) {
            if (typeof value === 'string') {
                value = value + '$';
            }
            if (value instanceof Array) {
                value = value.join('|') + '$';
            }
            this._allowedExt = value;
        },
        enumerable: true,
        configurable: true
    });
    FileInputAccessor.prototype.writeValue = function (value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', null);
    };
    FileInputAccessor.prototype.registerOnChange = function (fn) {
        this.onChange = this.onChangeGenerator(fn);
    };
    FileInputAccessor.prototype.registerOnTouched = function (fn) { };
    FileInputAccessor.prototype.setDisabledState = function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    FileInputAccessor.prototype.validate = function (c) {
        return this.validator(c);
    };
    /**
     * Generator method that I used to move the code for the AsyncValidator down here so it didn't
     * get in my way, way up there ^.
     */
    FileInputAccessor.prototype.generateAsyncValidator = function () {
        var _this = this;
        return function (c) {
            var e_1, _a;
            if (!c.value || !c.value.length || c.disabled)
                return of({});
            var errors = {};
            var loaders = [];
            var _loop_1 = function (f) {
                if (_this.size && _this.size < f.size) {
                    f.errors.fileSize = true;
                    errors.fileSize = true;
                }
                if (f.isImg && (_this.maxWidth || _this.maxHeight || _this.minWidth || _this.minHeight)) {
                    loaders.push(f.imgLoadReplay
                        .pipe(take(1), map(function (e) {
                        var minWidthError = _this.minWidth && f.imgWidth < _this.minWidth;
                        var minHeightError = _this.minHeight && f.imgHeight < _this.minHeight;
                        var maxWidthError = _this.maxWidth && f.imgWidth > _this.maxWidth;
                        var maxHeightError = _this.maxHeight && f.imgHeight > _this.maxHeight;
                        if (minWidthError) {
                            f.errors.minWidth = true;
                            errors.minWidth = true;
                        }
                        if (minHeightError) {
                            f.errors.minHeight = true;
                            errors.minHeight = true;
                        }
                        if (maxWidthError) {
                            f.errors.maxWidth = true;
                            errors.maxWidth = true;
                        }
                        if (maxHeightError) {
                            f.errors.maxHeight = true;
                            errors.maxHeight = true;
                        }
                        /** will be @deprecated **/
                        if (minWidthError || maxWidthError) {
                            f.errors.imageWidth = true;
                            errors.imageWidth = true;
                        }
                        /** will be @deprecated **/
                        if (minHeightError || maxHeightError) {
                            f.errors.imageHeight = true;
                            errors.imageHeight = true;
                        }
                        return e;
                    })));
                }
                if (!_this.allowedExt && !_this.allowedTypes)
                    return "continue";
                var extP = _this.generateRegExp(_this.allowedExt);
                var typeP = _this.generateRegExp(_this.allowedTypes);
                if (extP && !extP.test(f.name)) {
                    f.errors.fileExt = true;
                    errors.fileExt = true;
                }
                if (typeP && !typeP.test(f.type)) {
                    f.errors.fileType = true;
                    errors.fileType = true;
                }
            };
            try {
                for (var _b = __values(c.value), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var f = _c.value;
                    _loop_1(f);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (loaders.length) {
                return forkJoin.apply(void 0, __spread(loaders)).pipe(map(function () { return errors; }));
            }
            return of(errors);
        };
    };
    /**
     * Generator method that returns an onChange handler
     */
    FileInputAccessor.prototype.onChangeGenerator = function (fn) {
        var _this = this;
        return function (files) {
            var e_2, _a;
            var fileArr = [];
            try {
                for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                    var f = files_1_1.value;
                    if (_this.withMeta && FileReader) {
                        var fr = new FileReader();
                        _this.generateFileMeta(f, fr);
                    }
                    f.errors = {};
                    fileArr.push(f);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            fn(fileArr);
        };
    };
    FileInputAccessor.prototype.generateRegExp = function (pattern) {
        if (!pattern)
            return null;
        if (pattern instanceof RegExp) {
            return new RegExp(pattern);
        }
        else if (typeof pattern === 'string') {
            return new RegExp(pattern, 'ig');
        }
        else if (pattern instanceof Array) {
            return new RegExp("(" + pattern.join('|') + ")", 'ig');
        }
        return null;
    };
    /**
     * The ICustomFile has a ReplaySubject property for text / image files that will emit
     * once the file has been loaded. Might get removed later since I haven't found a use for it yet.
     */
    FileInputAccessor.prototype.generateFileMeta = function (f, fr) {
        if (f.type.match(/text.*/)) {
            f.textLoadReplay = this.setText(f, fr);
        }
        else if (f.type.match(/image.*/)) {
            f.imgLoadReplay = this.setImage(f, fr);
        }
    };
    FileInputAccessor.prototype.setImage = function (f, fr) {
        f.isImg = true;
        var img = new Image();
        var imgLoadObs = fromEventPattern((function (handler) { return img.addEventListener('load', handler); }), (function (handler) { return img.removeEventListener('load', handler); })).pipe(take(1), shareReplay());
        var frLoadObs = fromEventPattern((function (handler) { return fr.addEventListener('load', handler); }), (function (handler) { return fr.removeEventListener('load', handler); })).pipe(take(1), shareReplay());
        var onloadReplay = new ReplaySubject(1);
        forkJoin(imgLoadObs, frLoadObs).pipe(first()).subscribe(onloadReplay);
        imgLoadObs.pipe(first()).subscribe(function () {
            f.imgHeight = img.height;
            f.imgWidth = img.width;
        });
        frLoadObs.pipe(first()).subscribe(function () {
            f.imgSrc = fr.result + '';
            img.src = fr.result + '';
        });
        fr.readAsDataURL(f);
        return onloadReplay;
    };
    FileInputAccessor.prototype.setText = function (f, fr) {
        var frLoadObs = fromEventPattern((function (handler) { return fr.addEventListener('load', handler); }), (function (handler) { return fr.removeEventListener('load', handler); })).pipe(take(1), shareReplay());
        var onloadReplay = new ReplaySubject(1);
        frLoadObs.subscribe(onloadReplay);
        frLoadObs.pipe(first()).subscribe(function () {
            f.textContent = fr.result + '';
        });
        fr.readAsText(f);
        return onloadReplay;
    };
    var FileInputAccessor_1;
    FileInputAccessor.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FileInputAccessor.prototype, "allowedTypes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FileInputAccessor.prototype, "size", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], FileInputAccessor.prototype, "withMeta", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FileInputAccessor.prototype, "maxHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FileInputAccessor.prototype, "maxWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FileInputAccessor.prototype, "minHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], FileInputAccessor.prototype, "minWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], FileInputAccessor.prototype, "allowedExt", null);
    __decorate([
        HostListener('change', ['$event.target.files']),
        __metadata("design:type", Object)
    ], FileInputAccessor.prototype, "onChange", void 0);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Object)
    ], FileInputAccessor.prototype, "onTouched", void 0);
    FileInputAccessor = FileInputAccessor_1 = __decorate([
        Directive({
            selector: 'input[type=file][formControl],input[type=file][formControlName],input[type=file][ngModel]',
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return FileInputAccessor_1; }),
                    multi: true
                },
                {
                    provide: NG_ASYNC_VALIDATORS,
                    useExisting: forwardRef(function () { return FileInputAccessor_1; }),
                    multi: true
                }
            ]
        }),
        __metadata("design:paramtypes", [Renderer2, ElementRef])
    ], FileInputAccessor);
    return FileInputAccessor;
}());

var FileInputAccessorModule = /** @class */ (function () {
    function FileInputAccessorModule() {
    }
    FileInputAccessorModule = __decorate([
        NgModule({
            declarations: [FileInputAccessor],
            imports: [
                FormsModule,
                ReactiveFormsModule
            ],
            exports: [
                FileInputAccessor,
                FormsModule,
                ReactiveFormsModule
            ]
        })
    ], FileInputAccessorModule);
    return FileInputAccessorModule;
}());

/*
 * Public API Surface of file-input-accessor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FileInputAccessor, FileInputAccessorModule };
//# sourceMappingURL=file-input-accessor.js.map
